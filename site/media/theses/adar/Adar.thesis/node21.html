<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Lore</TITLE>
<META NAME="description" CONTENT="Lore">
<META NAME="keywords" CONTENT="main">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="main.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html474" HREF="node22.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html472" HREF="node19.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html468" HREF="node20.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html476" HREF="node2.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html475" HREF="node22.html">A Tale of Paper </A>
<B>Up:</B> <A NAME="tex2html473" HREF="node19.html">Technologies</A>
<B> Previous:</B> <A NAME="tex2html469" HREF="node20.html">Haystack</A>
<BR> <P>
<H2><A NAME="SECTION00522000000000000000">Lore</A></H2>
<A NAME="Ch2Lore">&#160;</A>
Although Haystack provides us with the interface to a variety of
information retrieval systems, it is necessary to find a suitable
database and hypertext system.  We were lucky to discover a system
that would provide us with a capability for both built-in.  The
Lightweight Object REpository (Lore) system from Stanford's database
group&nbsp;[<A HREF="node88.html#mchugh">32</A>] is a DBMS capable of querying and indexing
semi-structured information.  This ability satisfies our need to store
objects that do not have a pre-defined schema.  Lore is an extension
to the Object Database Management Groups (ODMG) database standard.
The language used to interact with Lore is known as Lorel (Lore
language) [<A HREF="node88.html#abiteboul">1</A>] and extends the Object Query Language (OQL)
language (which in turn extends the SQL standard).
<P>
<P><A NAME="291">&#160;</A><A NAME="figoem">&#160;</A> <IMG ALIGN=BOTTOM ALT="figure288" SRC="oem.gif"  > <BR>
<STRONG>Figure:</STRONG> A Sample OEM Graph<BR>
<P>
<P>
Lore data structures are based entirely Object Exchange Model
(<em>OEM</em>) objects.  These data structures can take on atomic values
such as <em>integer</em>, <em>real</em>, <em>string</em>, etc.  OEM objects
can also be complex.  Complex OEM objects contain named links to other
OEM objects.  Additionally, all OEM values carry a unique ID
(<em>OID</em>).  The structure formed by a Lore database can therefore
be an arbitrarily complex graph structure.
<P>
We will return to the specifics of Lore when discussing its
intergration into Haystack (see Chapter&nbsp;<A HREF="node44.html#ch6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>).  However, as some
basic knowledge of Lore is required for the next chapter, some
examples may help.  Figure&nbsp;<A HREF="node21.html#figoem"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> is a sample graph of a Lore
database.  The text on the connections between OEM nodes indicate the
named relationship between the parent (the higher node) to the child
(the lower node). The number inside the nodes is the OID of the
object.  The atomic values for those OEM that have them are shown
below the node in <em>italics</em>.
<P>
There are a number of important things to note about the graph
structure we generated.  The first, is the ability of
OEM objects to hold any number of ``children'' of a given type.  By
not pre-defining a schema we can connect any number of named links to
an object (<em>Address</em> for example).  Additionally, it is the link
which is named (i.e. is of a specific type) rather than the object it
points at.  This gives us the ability to connect to a number of
objects with the same link name regardless of how the objects are
represented.  For example, one of the <em>Address</em> nodes for the
``Eytan'' object is a complex OEM object pointing at three other OEM
objects: <em>Street</em>, <em>City</em>, and <em>Zip</em>.  The other
<em>Address</em> object is an atomic object with a string component.
Finally, we note the ability to explitly name objects, and to set
points to those objects.
<P>
<P><A NAME="338">&#160;</A><A NAME="figoemText">&#160;</A>  <CENTER>           &nbsp;<font face=symbol> &lt; </font
><tt>HaystackPeople::HaystackPeople</tt> { <br>
      &nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>GroupMember</tt> { <br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Name ``Eytan''</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>AD1: Address ``NE43-309''</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Address</tt> { <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Street ``Freeman St.''</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>City ``Brookline''</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Zip 02146</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Supervisor &amp;Lynn</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Supervisor &amp;David</tt><font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;}<font face=symbol> &gt; </font
> <br>
      &nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>GroupMember</tt> { <br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Name ``Mark''</tt><font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Address &amp;AD1</tt><font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;}<font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Lynn: GroupMember</tt> {<br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Name ``Lynn''</tt><font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Phone 2663</tt><font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;}<font face=symbol> &gt; </font
>      <br>       
      &nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>David: GroupMember</tt> {<br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>Name ``David''</tt><font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;&nbsp;<font face=symbol> &lt; </font
><tt>PhoneNumber ``6167''</tt><font face=symbol> &gt; </font
><br>
      &nbsp;&nbsp;}<font face=symbol> &gt; </font
> <br>            
      &nbsp;}<font face=symbol> &gt; </font
>   </CENTER>   
<BR>
<STRONG>Figure:</STRONG> A textual representation of the OEM graph<BR>
<P>
<P>
Figure&nbsp;<A HREF="node21.html#figoemText"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> is the corresponding textual OEM model that
is used to generated the graph.  An OEM ``object'' consists of a link
name followed by some value, between the signs ;<I>SPMlt</I>; and ;<I>SPMgt</I>;.  For
example, we create the Name node by specifying: ;<I>SPMlt</I>;<tt>Name
  ``Eytan''</tt>;<I>SPMgt</I>;.  To create a complex object, we place the
``children'' in braces: ;<I>SPMlt</I>;<tt>linkName {oemObject1, oemObject2,
  ...}</tt>;<I>SPMgt</I>;.  Finally, we can name objects by using placing a name
followed by a colon in the OEM ``constructor.''  For example:
;<I>SPMlt</I>;<tt>AD1: Address ``NE43-309''</tt>;<I>SPMgt</I>; binds the name <em>AD1</em> to
the object pointed at by the <em>Address</em> link (i.e.
<em>NE43-309</em>).  To point at a named object we use the ampersand
followed by the name of the object.  For example, in the ``Mark''
object, we point the <em>Address</em> at <em>AD1</em> by using:
;<I>SPMlt</I>;<em>Address &amp;AD1</em>;<I>SPMgt</I>;.  It is not necessary to use the same link
name in pointing to the same object.  We could have, for example,
said: ;<I>SPMlt</I>;<tt>Office &amp;AD1</tt>;<I>SPMgt</I>;.  This would have created an
<em>Office</em> link pointing at the <em>NE43-309</em> object.
<P>
Now that an OEM representation has been created, it is possible to
start asking Lore for information about this structure.  The Lorel
query syntax looks suprisingly like SQL.
<P>
<center>  SELECT <em>a</em>  FROM <em>b</em>  WHERE
  <i>c</i><sub>1</sub>  AND <i>c</i><sub>2</sub>  AND ....
</center>
<P>
The variable <em>a</em> is the view we want to take of the returned data
(i.e. how much of the data we want to see).  The data we query against
is limited to the set b, and we impose additional constraints with the
predicates <i>c</i><sub>1</sub>.  For example we can issue the query:
<P>
<PRE><TT> 
<tt>select X.PhoneNumber from HaystackPeople.GroupMember X</tt>
<P>
		<tt>where X.Name = ``David''</tt>
<P>
</TT></PRE>
<P>
This statement creates a set <em>X</em> of <em>GroupMembers</em>, we then
sonstrain the set to those group members whose <em>Name</em> is David.
Out of the result set, we select the object pointed at by the
<em>PhoneNumber</em> link.  In this case, we return ``6167.''  A slighly
more complex example is:
<P>
<PRE><TT> 
<tt>select X.#.Phone% from HaystackPeople X</tt>
<P>
		<tt>where X.GroupMember.Name = ``David''</tt>
<P>
</TT></PRE>
<P>
The two characters # and % are wildcard chracters.  The # is a path
wildcard charcater which will match any link name.  In the above
examples the # evaluates to: <em>GroupMember</em> (only a single path
in this example).  The <em>Phone%</em> means that we are looking for
links starting with the string <em>Phone</em>.  In this case,
<em>Phone</em> and <em>PhoneNumber</em> both satisfy the requirement.
However, the where clause limists us to the ``David''
<em>GroupMember</em>, and we again return ``6167.''  A complete
specification of Lorel is available in&nbsp;[<A HREF="node88.html#abiteboul">1</A>].
<P>
The final aspect of Lore that requires some discussion is the concept
of DataGuides [<A HREF="node88.html#goldman">19</A>].  Lore has the built in ability to take a
snapshot of the current database and produce a new database
representing the schema of the original.  Such a tool is highly useful
for visualizing the domain in which a user can query.  A user can, for
example, fill in differnt fields within the graph in order to perform
a query against the database.  This would allow a user to perform
queries without necessarily understanding the structure of the
database.  A DataGuide for the graph before is represented
in Figure&nbsp;<A HREF="node21.html#figdataGuide"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
<P><A NAME="394">&#160;</A><A NAME="figdataGuide">&#160;</A> <IMG ALIGN=BOTTOM ALT="figure391" SRC="dataGuide.gif"  > <BR>
<STRONG>Figure:</STRONG> A DataGuide Graph<BR>
<P>
<P>
<HR><A NAME="tex2html474" HREF="node22.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html472" HREF="node19.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html468" HREF="node20.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html476" HREF="node2.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html475" HREF="node22.html">A Tale of Paper </A>
<B>Up:</B> <A NAME="tex2html473" HREF="node19.html">Technologies</A>
<B> Previous:</B> <A NAME="tex2html469" HREF="node20.html">Haystack</A>
<P><ADDRESS>
Copyright 1998, Eytan Adar (eytan@alum.mit.edu)
</ADDRESS>
</BODY>
</HTML>
